Initialize a new Node.js project using the latest LTS version and create a clean project structure with `server.js` at the root and a `/public` folder containing `index.html`, `app.js`, and `style.css`. Install `express` and `ws`, configure Express to serve static files from the public directory, and create an HTTP server using `http.createServer(app)` so the WebSocket server can attach to it. Ensure the server listens on `process.env.PORT || 3000` for compatibility with free deployment platforms like Render. Instantiate a `WebSocketServer` bound to the HTTP server and maintain an in-memory `Map` called `rooms`, where each room ID maps to an object containing a `Set` of connected clients and an array storing drawing history. When a client connects, parse the `room` query parameter from the request URL, validate that it is a six-character alphanumeric string, create the room if it does not exist, enforce a maximum capacity of 20 clients per room, and add the client to the room’s client set. Immediately send an initialization message containing the existing stroke history so late joiners can reconstruct the canvas state. On receiving a message, first reject payloads exceeding 512 bytes, then parse the JSON and handle only structured message types such as `draw` and `clear`. For `draw` events, append the stroke object to the room’s history array while enforcing a maximum length (e.g., 10,000 strokes, removing the oldest entries when exceeded), and broadcast the stroke to all connected clients in that room whose WebSocket state is open. For `clear` events, reset the room’s history array and broadcast the clear instruction to all participants. On WebSocket close events, remove the client from its room and delete the room entirely if no clients remain. On the frontend, implement a full-screen HTML5 canvas with proper device pixel ratio scaling and resize handling, include a color picker and optional stroke width selector in a minimal side panel, and automatically generate a six-character room ID if none is present in the URL, redirecting the user accordingly. Establish a WebSocket connection dynamically using `ws` or `wss` based on the current protocol, and implement input handling for both mouse and touch events with a drawing state that tracks previous coordinates to emit structured stroke messages at a throttled rate of no more than 60 messages per second. On receiving `draw` messages, render line segments using `CanvasRenderingContext2D` methods, and on receiving `init`, replay the full stroke history sequentially; on receiving `clear`, wipe the canvas context completely. Ensure proper error handling for malformed JSON and unexpected message types to prevent server crashes. Add a start script in `package.json` using `"start": "node server.js"`, push the repository to GitHub, and deploy to Render using the Node runtime with `npm install` as the build command and `npm start` as the start command. Finally, validate that multiple users can draw simultaneously with low latency, new users correctly receive historical drawings, rooms self-delete when empty, oversized messages are ignored, and the application remains under typical free-tier memory limits (~100 MB), ensuring the system remains lightweight, stateless, and fully browser-based without requiring any database or authentication layer.



